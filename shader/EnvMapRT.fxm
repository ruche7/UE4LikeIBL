/// @file
/// @brief キューブ環境マップをレンダリングする。
/// @author ルーチェ

#include "common.h"

////////////////////
// レンダリング用定義ここから
////////////////////

/// カメラ位置。(＝環境マップの中心点)
float3 CameraPosition : CONTROLOBJECT < string name = "(OffscreenOwner)"; >;

/// ワールドマトリクス。
float4x4 WorldMatrix : WORLD;

/// @brief プロジェクションマトリクス。視野角 90° 。
///
/// fov    == 視野角 90°
/// aspect == アスペクト比 1.0
///
/// h  == cot(fov/2) == cos(45°)/sin(45°) == +1
/// w  == h / aspect == +1
/// zn == UE4LIKEIBL_ENVMAP_NEAR
/// zf == UE4LIKEIBL_ENVMAP_FAR
///
/// proj == float4x4( w, 0,              0, 0,
///                   0, h,              0, 0,
///                   0, 0,     zf/(zf-zn), 1,
///                   0, 0, -zn*zf/(zf-zn), 0 )
float4x4 ProjMatrix =
    float4x4(
        float4(+1, 0, 0, 0),
        float4( 0,+1, 0, 0),
        float4(
            0,
            0,
            (UE4LIKEIBL_ENVMAP_FAR) /
            ((UE4LIKEIBL_ENVMAP_FAR) - (UE4LIKEIBL_ENVMAP_NEAR)),
            1),
        float4(
            0,
            0,
            -(UE4LIKEIBL_ENVMAP_NEAR) *
            (UE4LIKEIBL_ENVMAP_FAR) /
            ((UE4LIKEIBL_ENVMAP_FAR) - (UE4LIKEIBL_ENVMAP_NEAR)),
            0));

/// キューブ面ごとの方向ベクトル。
float3 DirectionOfFaces[6] =
    {
        float3(+1,  0,  0), // +X
        float3(-1,  0,  0), // -X
        float3( 0, +1,  0), // +Y
        float3( 0, -1,  0), // -Y
        float3( 0,  0, +1), // +Z
        float3( 0,  0, -1), // -Z
    };

/// @brief キューブ面ごとのビューマトリクスを作成する。
/// @param[in] face 面インデックス。
/// @return ビューマトリクス。
float4x4 MakeViewMatrix(uniform int face)
{
    // eye == カメラ位置
    // at  == 注視点
    // up  == 上方向ベクトル
    //
    // zaxis == at - eye
    // xaxis == cross(up, zaxis)
    // yaxis == cross(zaxis, xaxis)
    //
    // trans == float3(-dot(xaxis, eye), -dot(yaxis, eye), -dot(zaxis, eye))
    //
    // view == float4x4( xaxis.x, yaxis.x, zaxis.x, 0,
    //                   xaxis.y, yaxis.y, zaxis.y, 0,
    //                   xaxis.z, yaxis.z, zaxis.z, 0,
    //                   trans.x, trans.y, trans.z, 1 )

    float3 z_axis = DirectionOfFaces[face];
    float3 x_axis = float3(abs(z_axis.y) + z_axis.z, 0, -z_axis.x);
    float3 y_axis = float3(0, abs(z_axis.x + z_axis.z), -z_axis.y);

    return
        float4x4(
            float4(x_axis.x, y_axis.x, z_axis.x, 0),
            float4(x_axis.y, y_axis.y, z_axis.y, 0),
            float4(x_axis.z, y_axis.z, z_axis.z, 0),
            float4(
                -dot(x_axis, CameraPosition),
                -dot(y_axis, CameraPosition),
                -dot(z_axis, CameraPosition),
                1));
}

/// キューブ面ごとのビューマトリクス。
static float4x4 ViewMatrixOfFaces[6] =
    {
        MakeViewMatrix(0),
        MakeViewMatrix(1),
        MakeViewMatrix(2),
        MakeViewMatrix(3),
        MakeViewMatrix(4),
        MakeViewMatrix(5),
    };

/// キューブ面ごとのワールドビュープロジェクションマトリクス。
static float4x4 WorldViewProjMatrixOfFaces[6] =
    {
        mul(mul(WorldMatrix, ViewMatrixOfFaces[0]), ProjMatrix),
        mul(mul(WorldMatrix, ViewMatrixOfFaces[1]), ProjMatrix),
        mul(mul(WorldMatrix, ViewMatrixOfFaces[2]), ProjMatrix),
        mul(mul(WorldMatrix, ViewMatrixOfFaces[3]), ProjMatrix),
        mul(mul(WorldMatrix, ViewMatrixOfFaces[4]), ProjMatrix),
        mul(mul(WorldMatrix, ViewMatrixOfFaces[5]), ProjMatrix),
    };

/// キューブの各面レンダリング位置へのスケーリングマトリクス。
float4x4 CubeScaleMatrix =
    float4x4(
        float4(UE4LIKEIBL_ENVMAP_CUBE_SCALE,                            0, 0, 0),
        float4(                           0, UE4LIKEIBL_ENVMAP_CUBE_SCALE, 0, 0),
        float4(                           0,                            0, 1, 0),
        float4(                           0,                            0, 0, 1));

/// キューブの各面レンダリング位置への X, Y 並行移動量。
float2 CubeTranslateOfFaces[6] =
    {
        UE4LIKEIBL_ENVMAP_CUBE_TRANS_PX,
        UE4LIKEIBL_ENVMAP_CUBE_TRANS_NX,
        UE4LIKEIBL_ENVMAP_CUBE_TRANS_PY,
        UE4LIKEIBL_ENVMAP_CUBE_TRANS_NY,
        UE4LIKEIBL_ENVMAP_CUBE_TRANS_PZ,
        UE4LIKEIBL_ENVMAP_CUBE_TRANS_NZ,
    };

/// @brief 射影変換済みの座標をキューブの各面レンダリング位置へ移動させる。
/// @param[in] pos 射影変換済みの座標。
/// @param[in] face 面インデックス。
/// @return 各面レンダリング位置へ移動させた座標。
///
/// 各面は下記のような配置でレンダリングされる。
/// 原点は +Z, +X, -Y の3面の中心である。
///
/// |  |+Y|  |  |
/// |-X|+Z|+X|-Z|
/// |  |-Y|  |  |
/// |  |  |  |  |
///
/// まず 1/4 にスケーリングした後、目的の位置へ平行移動させる。
float4 CalcPositionForCube(float4 pos, uniform int face)
{
    float4x4 trans =
        float4x4(
            float4(1, 0, 0, 0),
            float4(0, 1, 0, 0),
            float4(0, 0, 1, 0),
            float4(CubeTranslateOfFaces[face], 0, 1));
    return mul(mul(pos, CubeScaleMatrix), trans);
}

/// @brief クリッピング判定 cos 値。
///
/// 正確には cos(45°) ≒ 0.70710678… だが、エッジ対策で少しだけ許容角度を取る。
#define UE4LIKEIBL_ENVMAP_CLIP_COS 0.7068f

/// @brief ピクセルシェーダに渡されたカメラの相対位置を基にクリッピング判定を行う。
/// @param[in] eye ピクセルシェーダに渡されたカメラの相対位置。
/// @param[in] face 面インデックス。
void ClipForCube(float3 eye, uniform int face)
{
    // 対象面方向取得
    float3 dir = DirectionOfFaces[face];

    // X, Y, Z のうち 1 要素だけ 0 にするためのベクトルを作成
    // +X 面や -X 面なら X 要素は 0 にしない
    float3 ad = abs(dir);
    float3 vdA = ad + ad.yzx;
    float3 vdB = ad + ad.zxy;

    // 対象面方向ともう1方向を軸とする2D平面へ投影した視線ベクトルと
    // 対象面方向との角度が成す cos 値を算出して判定
    clip(dot(dir, normalize(-eye * vdA)) - (UE4LIKEIBL_ENVMAP_CLIP_COS));
    clip(dot(dir, normalize(-eye * vdB)) - (UE4LIKEIBL_ENVMAP_CLIP_COS));
}

/// 背景色。
float4 BackGroundColor : BACKGROUNDCOLOR;

/// @brief テクニックで全キューブ面を描画するためのスクリプトマクロ。
/// @param[in] baseName パスのベース名。
#define UE4LIKEIBL_TEC_SCRIPT_DEF(baseName) \
    "RenderColorTarget0=;" \
    "RenderDepthStencilTarget=;" \
    "ClearSetColor=BackGroundColor;" \
    "Clear=Color;" \
    "Pass=" #baseName "0;" \
    "Pass=" #baseName "1;" \
    "Pass=" #baseName "2;" \
    "Pass=" #baseName "3;" \
    "Pass=" #baseName "4;" \
    "Pass=" #baseName "5;"

/// 輪郭と地面影の頂点シェーダ出力構造体。
struct EdgeShadowVSOutput
{
    float4 pos : POSITION;  ///< 射影変換座標。
    float3 eye : TEXCOORD3; ///< カメラとの相対位置。
};

////////////////////
// レンダリング用定義ここまで
////////////////////

// 以下は SampleBase.fxm をコピペしてコード変更したもの。
// 変更箇所は #if 〜 #endif で括られている。
////////////////////////////////////////////////////////////////////////////////////////////////
//
//  MikuMikuMoving用サンプルシェーダ
//  2013/05/01
//
////////////////////////////////////////////////////////////////////////////////////////////////
// パラメータ宣言

#if 0

//座標変換行列
float4x4 WorldViewProjMatrix	: WORLDVIEWPROJECTION;
float4x4 WorldMatrix		: WORLD;
float4x4 ViewMatrix		: VIEW;
float4x4 ProjMatrix		: PROJECTION;

#endif // 0

//ライト関連
bool	 LightEnables[MMM_LightCount]		: LIGHTENABLES;		// 有効フラグ
float4x4 LightWVPMatrices[MMM_LightCount]	: LIGHTWVPMATRICES;	// 座標変換行列
float3   LightDirection[MMM_LightCount]		: LIGHTDIRECTIONS;	// 方向
float3   LightPositions[MMM_LightCount]		: LIGHTPOSITIONS;	// ライト位置
float    LightZFars[MMM_LightCount]			: LIGHTZFARS;		// ライトzFar値

//材質モーフ関連
float4	 AddingTexture		  : ADDINGTEXTURE;	// 材質モーフ加算Texture値
float4	 AddingSphere		  : ADDINGSPHERE;	// 材質モーフ加算SphereTexture値
float4	 MultiplyTexture	  : MULTIPLYINGTEXTURE;	// 材質モーフ乗算Texture値
float4	 MultiplySphere		  : MULTIPLYINGSPHERE;	// 材質モーフ乗算SphereTexture値

#if 0

//カメラ位置
float3	 CameraPosition		: POSITION  < string Object = "Camera"; >;

#endif // 0

// マテリアル色
float4   MaterialDiffuse	: DIFFUSE  < string Object = "Geometry"; >;
float3   MaterialAmbient	: AMBIENT  < string Object = "Geometry"; >;
float3   MaterialEmmisive	: EMISSIVE < string Object = "Geometry"; >;
float3   MaterialSpecular	: SPECULAR < string Object = "Geometry"; >;
float    SpecularPower		: SPECULARPOWER < string Object = "Geometry"; >;
float4   MaterialToon		: TOONCOLOR;
float4   EdgeColor			: EDGECOLOR;
float    EdgeWidth			: EDGEWIDTH;
float4   GroundShadowColor	: GROUNDSHADOWCOLOR;

bool	 spadd;    			// スフィアマップ加算合成フラグ
bool     usetoontexturemap;	// Toonテクスチャフラグ

// ライト色
float3   LightDiffuses[MMM_LightCount]      : LIGHTDIFFUSECOLORS;
float3   LightAmbients[MMM_LightCount]      : LIGHTAMBIENTCOLORS;
float3   LightSpeculars[MMM_LightCount]     : LIGHTSPECULARCOLORS;

// ライト色
static float4 DiffuseColor[3]  = { MaterialDiffuse * float4(LightDiffuses[0], 1.0f)
				 , MaterialDiffuse * float4(LightDiffuses[1], 1.0f)
				 , MaterialDiffuse * float4(LightDiffuses[2], 1.0f)};
static float3 AmbientColor[3]  = { saturate(MaterialAmbient * LightAmbients[0]) + MaterialEmmisive
				 , saturate(MaterialAmbient * LightAmbients[1]) + MaterialEmmisive
				 , saturate(MaterialAmbient * LightAmbients[2]) + MaterialEmmisive};
static float3 SpecularColor[3] = { MaterialSpecular * LightSpeculars[0]
				 , MaterialSpecular * LightSpeculars[1]
				 , MaterialSpecular * LightSpeculars[2]};

// オブジェクトのテクスチャ
texture ObjectTexture: MATERIALTEXTURE;
sampler ObjTexSampler = sampler_state {
	texture = <ObjectTexture>;
	MINFILTER = LINEAR;
	MAGFILTER = LINEAR;
};

// スフィアマップのテクスチャ
texture ObjectSphereMap: MATERIALSPHEREMAP;
sampler ObjSphareSampler = sampler_state {
	texture = <ObjectSphereMap>;
	MINFILTER = LINEAR;
	MAGFILTER = LINEAR;
};

///////////////////////////////////////////////////////////////////////////////////////////////
// オブジェクト描画
struct VS_OUTPUT {
	float4 Pos		: POSITION;		// 射影変換座標
	float2 Tex		: TEXCOORD0;	// テクスチャ
	float4 SubTex	: TEXCOORD1;	// サブテクスチャ/スフィアマップテクスチャ座標
	float3 Normal	: TEXCOORD2;	// 法線
	float3 Eye		: TEXCOORD3;	// カメラとの相対位置
	float4 SS_UV1   : TEXCOORD4;	// セルフシャドウテクスチャ座標
	float4 SS_UV2   : TEXCOORD5;	// セルフシャドウテクスチャ座標
	float4 SS_UV3   : TEXCOORD6;	// セルフシャドウテクスチャ座標
	float4 Color	: COLOR0;		// ライト0による色
};

//==============================================
// 頂点シェーダ
// MikuMikuMoving独自の頂点シェーダ入力(MMM_SKINNING_INPUT)
//==============================================
#if 1
VS_OUTPUT Basic_VS(MMM_SKINNING_INPUT IN, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon, uniform bool useSelfShadow, uniform int face)
#else
VS_OUTPUT Basic_VS(MMM_SKINNING_INPUT IN, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon, uniform bool useSelfShadow)
#endif
{
#if 1
    float4x4 ViewMatrix = ViewMatrixOfFaces[face];
#endif

	VS_OUTPUT Out = (VS_OUTPUT)0;

	//================================================================================
	//MikuMikuMoving独自のスキニング関数(MMM_SkinnedPositionNormal)。座標と法線を取得する。
	//================================================================================
	MMM_SKINNING_OUTPUT SkinOut = MMM_SkinnedPositionNormal(IN.Pos, IN.Normal, IN.BlendWeight, IN.BlendIndices, IN.SdefC, IN.SdefR0, IN.SdefR1);

	// カメラとの相対位置
	Out.Eye = CameraPosition - mul( SkinOut.Position, WorldMatrix ).xyz;
	// 頂点法線
	Out.Normal = normalize( mul( SkinOut.Normal, (float3x3)WorldMatrix ) );

	// 頂点座標
	if (MMM_IsDinamicProjection)
	{
		float4x4 wvpmat = mul(mul(WorldMatrix, ViewMatrix), MMM_DynamicFov(ProjMatrix, length(Out.Eye)));
		Out.Pos = mul( SkinOut.Position, wvpmat );
	}
	else
	{
#if 1
        float4x4 WorldViewProjMatrix = WorldViewProjMatrixOfFaces[face];
#endif
		Out.Pos = mul( SkinOut.Position, WorldViewProjMatrix );
	}

	// ディフューズ色＋アンビエント色 計算
	float3 color = float3(0, 0, 0);
	float3 ambient = float3(0, 0, 0);
	float count = 0;
	for (int i = 0; i < 3; i++) {
		if (LightEnables[i]) {
			color += (float3(1,1,1) - color) * (max(0, DiffuseColor[i] * dot(Out.Normal, -LightDirection[i])));
			ambient += AmbientColor[i];
			count = count + 1.0;
		}
	}
	Out.Color.rgb = saturate(ambient / count + color);
	Out.Color.a = MaterialDiffuse.a;

	// テクスチャ座標
	Out.Tex = IN.Tex;
	Out.SubTex.xy = IN.AddUV1.xy;

	if ( useSphereMap ) {
		// スフィアマップテクスチャ座標
		float2 NormalWV = mul( Out.Normal, (float3x3)ViewMatrix );
		Out.SubTex.z = NormalWV.x * 0.5f + 0.5f;
		Out.SubTex.w = NormalWV.y * -0.5f + 0.5f;
	}
    
	if (useSelfShadow) {
		float4 dpos = mul(SkinOut.Position, WorldMatrix);
		//デプスマップテクスチャ座標
		Out.SS_UV1 = mul(dpos, LightWVPMatrices[0]);
		Out.SS_UV2 = mul(dpos, LightWVPMatrices[1]);
		Out.SS_UV3 = mul(dpos, LightWVPMatrices[2]);
		
		Out.SS_UV1.y = -Out.SS_UV1.y;
		Out.SS_UV2.y = -Out.SS_UV2.y;
		Out.SS_UV3.y = -Out.SS_UV3.y;

		Out.SS_UV1.z = (length(LightPositions[0] - SkinOut.Position) / LightZFars[0]);
		Out.SS_UV2.z = (length(LightPositions[1] - SkinOut.Position) / LightZFars[1]);
		Out.SS_UV3.z = (length(LightPositions[2] - SkinOut.Position) / LightZFars[2]);
	}

#if 1
    Out.Pos = CalcPositionForCube(Out.Pos, face);
#endif

	return Out;
}

//==============================================
// ピクセルシェーダ
// 入力は特に独自形式なし
//==============================================
#if 1
float4 Basic_PS(VS_OUTPUT IN, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon, uniform bool useSelfShadow, uniform int face) : COLOR0
#else
float4 Basic_PS(VS_OUTPUT IN, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon, uniform bool useSelfShadow) : COLOR0
#endif
{
#if 1
    ClipForCube(IN.Eye, face);
#endif

	float4 Color = IN.Color;
	float4 texColor = float4(1,1,1,1);
	float  texAlpha = MultiplyTexture.a + AddingTexture.a;

	//スペキュラ色計算
	float3 HalfVector;
	float3 Specular = 0;
	for (int i = 0; i < 3; i++) {
		if (LightEnables[i]) {
			HalfVector = normalize( normalize(IN.Eye) + -LightDirection[i] );
			Specular += pow( max(0,dot( HalfVector, normalize(IN.Normal) )), SpecularPower ) * SpecularColor[i];
		}
	}

	// テクスチャ適用
	if (useTexture) {
		texColor = tex2D(ObjTexSampler, IN.Tex);
		texColor.rgb = (texColor.rgb * MultiplyTexture.rgb + AddingTexture.rgb) * texAlpha + (1.0 - texAlpha);
	}
	Color.rgb *= texColor.rgb;

	// スフィアマップ適用
	if ( useSphereMap ) {
		// スフィアマップ適用
		if(spadd) Color.rgb = Color.rgb + (tex2D(ObjSphareSampler,IN.SubTex.zw).rgb * MultiplySphere.rgb + AddingSphere.rgb);
		else      Color.rgb = Color.rgb * (tex2D(ObjSphareSampler,IN.SubTex.zw).rgb * MultiplySphere.rgb + AddingSphere.rgb);
	}
	// アルファ適用
	Color.a = IN.Color.a * texColor.a;

	// セルフシャドウなしのトゥーン適用
	float3 color;
	if (!useSelfShadow && useToon && usetoontexturemap ) {
		//================================================================================
		// MikuMikuMovingデフォルトのトゥーン色を取得する(MMM_GetToonColor)
		//================================================================================
		color = MMM_GetToonColor(MaterialToon, IN.Normal, LightDirection[0], LightDirection[1], LightDirection[2]);
		Color.rgb *= color;
	}
	// セルフシャドウ
	if (useSelfShadow) {

		if (useToon && usetoontexturemap) {
			//================================================================================
			// MikuMikuMovingデフォルトのセルフシャドウ色を取得する(MMM_GetSelfShadowToonColor)
			//================================================================================
			float3 shadow = MMM_GetToonColor(MaterialToon, IN.Normal, LightDirection[0], LightDirection[1], LightDirection[2]);
			color = MMM_GetSelfShadowToonColor(MaterialToon, IN.Normal, IN.SS_UV1, IN.SS_UV2, IN.SS_UV3, false, useToon);

			Color.rgb *= min(shadow, color);
		}
		else {
			Color.rgb *= MMM_GetSelfShadowToonColor(MaterialToon, IN.Normal, IN.SS_UV1, IN.SS_UV2, IN.SS_UV3, false, useToon);
		}
	}

	// スペキュラ適用
	Color.rgb += Specular;

    return Color;
}

//==============================================
// オブジェクト描画テクニック
// UseSelfShadowが独自に追加されています。
//==============================================
#if 1

#define UE4LIKEIBL_DRAWOBJECT_PASS_DEF(u_tex,u_sph,u_toon,u_ss,face) \
    pass DrawObject##face { \
        VertexShader = compile vs_3_0 Basic_VS(u_tex, u_sph, u_toon, u_ss, face); \
        PixelShader = compile ps_3_0 Basic_PS(u_tex, u_sph, u_toon, u_ss, face); }

#define UE4LIKEIBL_MAIN_TEC_DEF(idx,u_tex,u_sph,u_toon,u_ss) \
    technique MainTec##idx < \
        string MMDPass = "object"; \
        bool UseTexture = u_tex; \
        bool UseSphereMap = u_sph; \
        bool UseToon = u_toon; \
        bool UseSelfShadow = u_ss; \
        string Script = UE4LIKEIBL_TEC_SCRIPT_DEF(DrawObject); \
    > { \
        UE4LIKEIBL_DRAWOBJECT_PASS_DEF(u_tex,u_sph,u_toon,u_ss,0) \
        UE4LIKEIBL_DRAWOBJECT_PASS_DEF(u_tex,u_sph,u_toon,u_ss,1) \
        UE4LIKEIBL_DRAWOBJECT_PASS_DEF(u_tex,u_sph,u_toon,u_ss,2) \
        UE4LIKEIBL_DRAWOBJECT_PASS_DEF(u_tex,u_sph,u_toon,u_ss,3) \
        UE4LIKEIBL_DRAWOBJECT_PASS_DEF(u_tex,u_sph,u_toon,u_ss,4) \
        UE4LIKEIBL_DRAWOBJECT_PASS_DEF(u_tex,u_sph,u_toon,u_ss,5) }

UE4LIKEIBL_MAIN_TEC_DEF(0,  false, false, false, false)
UE4LIKEIBL_MAIN_TEC_DEF(1,  true , false, false, false)
UE4LIKEIBL_MAIN_TEC_DEF(2,  false, true , false, false)
UE4LIKEIBL_MAIN_TEC_DEF(3,  true , true , false, false)
UE4LIKEIBL_MAIN_TEC_DEF(4,  false, false, true , false)
UE4LIKEIBL_MAIN_TEC_DEF(5,  true , false, true , false)
UE4LIKEIBL_MAIN_TEC_DEF(6,  false, true , true , false)
UE4LIKEIBL_MAIN_TEC_DEF(7,  true , true , true , false)
UE4LIKEIBL_MAIN_TEC_DEF(8,  false, false, false, true )
UE4LIKEIBL_MAIN_TEC_DEF(9,  true , false, false, true )
UE4LIKEIBL_MAIN_TEC_DEF(10, false, true , false, true )
UE4LIKEIBL_MAIN_TEC_DEF(11, true , true , false, true )
UE4LIKEIBL_MAIN_TEC_DEF(12, false, false, true , true )
UE4LIKEIBL_MAIN_TEC_DEF(13, true , false, true , true )
UE4LIKEIBL_MAIN_TEC_DEF(14, false, true , true , true )
UE4LIKEIBL_MAIN_TEC_DEF(15, true , true , true , true )

#else
technique MainTec0 < string MMDPass = "object"; bool UseTexture = false; bool UseSphereMap = false; bool UseToon = false; bool UseSelfShadow = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(false, false, false, false);
        PixelShader  = compile ps_3_0 Basic_PS(false, false, false, false);
    }
}

technique MainTec1 < string MMDPass = "object"; bool UseTexture = true; bool UseSphereMap = false; bool UseToon = false; bool UseSelfShadow = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(true, false, false, false);
        PixelShader  = compile ps_3_0 Basic_PS(true, false, false, false);
    }
}

technique MainTec2 < string MMDPass = "object"; bool UseTexture = false; bool UseSphereMap = true; bool UseToon = false; bool UseSelfShadow = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(false, true, false, false);
        PixelShader  = compile ps_3_0 Basic_PS(false, true, false, false);
    }
}

technique MainTec3 < string MMDPass = "object"; bool UseTexture = true; bool UseSphereMap = true; bool UseToon = false; bool UseSelfShadow = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(true, true, false, false);
        PixelShader  = compile ps_3_0 Basic_PS(true, true, false, false);
    }
}

technique MainTec4 < string MMDPass = "object"; bool UseTexture = false; bool UseSphereMap = false; bool UseToon = true; bool UseSelfShadow = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(false, false, true, false);
        PixelShader  = compile ps_3_0 Basic_PS(false, false, true, false);
    }
}

technique MainTec5 < string MMDPass = "object"; bool UseTexture = true; bool UseSphereMap = false; bool UseToon = true; bool UseSelfShadow = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(true, false, true, false);
        PixelShader  = compile ps_3_0 Basic_PS(true, false, true, false);
    }
}

technique MainTec6 < string MMDPass = "object"; bool UseTexture = false; bool UseSphereMap = true; bool UseToon = true; bool UseSelfShadow = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(false, true, true, false);
        PixelShader  = compile ps_3_0 Basic_PS(false, true, true, false);
    }
}

technique MainTec7 < string MMDPass = "object"; bool UseTexture = true; bool UseSphereMap = true; bool UseToon = true; bool UseSelfShadow = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(true, true, true, false);
        PixelShader  = compile ps_3_0 Basic_PS(true, true, true, false);
    }
}
technique MainTec8 < string MMDPass = "object"; bool UseTexture = false; bool UseSphereMap = false; bool UseToon = false; bool UseSelfShadow = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(false, false, false, true);
        PixelShader  = compile ps_3_0 Basic_PS(false, false, false, true);
    }
}

technique MainTec9 < string MMDPass = "object"; bool UseTexture = true; bool UseSphereMap = false; bool UseToon = false; bool UseSelfShadow = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(true, false, false, true);
        PixelShader  = compile ps_3_0 Basic_PS(true, false, false, true);
    }
}

technique MainTec10 < string MMDPass = "object"; bool UseTexture = false; bool UseSphereMap = true; bool UseToon = false; bool UseSelfShadow = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(false, true, false, true);
        PixelShader  = compile ps_3_0 Basic_PS(false, true, false, true);
    }
}

technique MainTec11 < string MMDPass = "object"; bool UseTexture = true; bool UseSphereMap = true; bool UseToon = false; bool UseSelfShadow = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(true, true, false, true);
        PixelShader  = compile ps_3_0 Basic_PS(true, true, false, true);
    }
}

technique MainTec12 < string MMDPass = "object"; bool UseTexture = false; bool UseSphereMap = false; bool UseToon = true; bool UseSelfShadow = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(false, false, true, true);
        PixelShader  = compile ps_3_0 Basic_PS(false, false, true, true);
    }
}

technique MainTec13 < string MMDPass = "object"; bool UseTexture = true; bool UseSphereMap = false; bool UseToon = true; bool UseSelfShadow = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(true, false, true, true);
        PixelShader  = compile ps_3_0 Basic_PS(true, false, true, true);
    }
}

technique MainTec14 < string MMDPass = "object"; bool UseTexture = false; bool UseSphereMap = true; bool UseToon = true; bool UseSelfShadow = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(false, true, true, true);
        PixelShader  = compile ps_3_0 Basic_PS(false, true, true, true);
    }
}

technique MainTec15 < string MMDPass = "object"; bool UseTexture = true; bool UseSphereMap = true; bool UseToon = true; bool UseSelfShadow = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(true, true, true, true);
        PixelShader  = compile ps_3_0 Basic_PS(true, true, true, true);
    }
}
#endif

////////////////////////////////////////////////////////////////////////////////////////////////
// 輪郭描画

//==============================================
// 頂点シェーダ
//==============================================
#if 1
EdgeShadowVSOutput Edge_VS(MMM_SKINNING_INPUT IN, uniform int face)
#else
float4 Edge_VS(MMM_SKINNING_INPUT IN) : POSITION 
#endif
{
#if 1
    EdgeShadowVSOutput Out = (EdgeShadowVSOutput)0;
    float4x4 ViewMatrix = ViewMatrixOfFaces[face];
#endif

	//================================================================================
	//MikuMikuMoving独自のスキニング関数(MMM_SkinnedPosition)。座標を取得する。
	//================================================================================
	MMM_SKINNING_OUTPUT SkinOut = MMM_SkinnedPositionNormal(IN.Pos, IN.Normal, IN.BlendWeight, IN.BlendIndices, IN.SdefC, IN.SdefR0, IN.SdefR1);

	float4 position = SkinOut.Position;

	// 頂点座標
	if (MMM_IsDinamicProjection)
	{
		float dist = length(CameraPosition - mul( position, WorldMatrix ));
		float4x4 wvpmat = mul(mul(WorldMatrix, ViewMatrix), MMM_DynamicFov(ProjMatrix, dist));

		position = position + float4(SkinOut.Normal, 0) * IN.EdgeWeight * EdgeWidth * distance(SkinOut.Position.xyz, CameraPosition) * MMM_GetDynamicFovEdgeRate(dist);
#if 1
        Out.pos = mul( position, wvpmat );
#else
		return mul( position, wvpmat );
#endif
	}
	else
	{
		position = position + float4(SkinOut.Normal, 0) * IN.EdgeWeight * EdgeWidth * distance(SkinOut.Position.xyz, CameraPosition);
#if 1
        float4x4 WorldViewProjMatrix = WorldViewProjMatrixOfFaces[face];
        Out.pos = mul( position, WorldViewProjMatrix );
#else
		return mul( position, WorldViewProjMatrix );
#endif
	}

#if 1
    Out.pos = CalcPositionForCube(Out.pos, face);
    Out.eye = CameraPosition - mul(position, WorldMatrix).xyz;
    return Out;
#endif
}

//==============================================
// ピクセルシェーダ
//==============================================
#if 1
float4 Edge_PS(EdgeShadowVSOutput IN, uniform int face) : COLOR
#else
float4 Edge_PS() : COLOR
#endif
{
#if 1
    clip(EdgeWidth - 0.000001f);
    ClipForCube(IN.eye, face);
#endif

	// 輪郭色で塗りつぶし
	return EdgeColor;
}

//==============================================
// 輪郭描画テクニック
//==============================================
#if 1

#define UE4LIKEIBL_DRAWEDGE_PASS_DEF(face) \
    pass DrawEdge##face { \
        AlphaBlendEnable = false; \
        AlphaTestEnable = false; \
        VertexShader = compile vs_3_0 Edge_VS(face); \
        PixelShader = compile ps_3_0 Edge_PS(face); }

technique EdgeTec <
    string MMDPass = "edge";
    string Script = UE4LIKEIBL_TEC_SCRIPT_DEF(DrawEdge); >
{
    UE4LIKEIBL_DRAWEDGE_PASS_DEF(0)
    UE4LIKEIBL_DRAWEDGE_PASS_DEF(1)
    UE4LIKEIBL_DRAWEDGE_PASS_DEF(2)
    UE4LIKEIBL_DRAWEDGE_PASS_DEF(3)
    UE4LIKEIBL_DRAWEDGE_PASS_DEF(4)
    UE4LIKEIBL_DRAWEDGE_PASS_DEF(5)
}

#else
technique EdgeTec < string MMDPass = "edge"; > {
	pass DrawEdge {
		AlphaBlendEnable = FALSE;
		AlphaTestEnable  = FALSE;

		VertexShader = compile vs_2_0 Edge_VS();
		PixelShader  = compile ps_2_0 Edge_PS();
	}
}
#endif

///////////////////////////////////////////////////////////////////////////////////////////////
// 影（非セルフシャドウ）描画

//==============================================
// 頂点シェーダ
//==============================================
#if 1
EdgeShadowVSOutput Shadow_VS(MMM_SKINNING_INPUT IN, uniform int face)
#else
float4 Shadow_VS(MMM_SKINNING_INPUT IN) : POSITION
#endif
{
#if 1
    EdgeShadowVSOutput Out = (EdgeShadowVSOutput)0;
    float4x4 WorldViewProjMatrix = WorldViewProjMatrixOfFaces[face];
#endif

	//================================================================================
	//MikuMikuMoving独自のスキニング関数(MMM_SkinnedPosition)。座標を取得する。
	//================================================================================
	float4 position = MMM_SkinnedPosition(IN.Pos, IN.BlendWeight, IN.BlendIndices, IN.SdefC, IN.SdefR0, IN.SdefR1);

#if 1
    Out.pos = CalcPositionForCube(mul(position, WorldViewProjMatrix), face);
    Out.eye = CameraPosition - mul(position, WorldMatrix).xyz;
    return Out;
#else
    // カメラ視点のワールドビュー射影変換
    return mul( position, WorldViewProjMatrix );
#endif
}

//==============================================
// ピクセルシェーダ
//==============================================
#if 1
float4 Shadow_PS(EdgeShadowVSOutput IN, uniform int face) : COLOR
#else
float4 Shadow_PS() : COLOR
#endif
{
#if 1
    ClipForCube(IN.eye, face);
#endif

    return GroundShadowColor;
}

//==============================================
// 地面影描画テクニック
//==============================================
#if 1

#define UE4LIKEIBL_DRAWSHADOW_PASS_DEF(face) \
    pass DrawShadow##face { \
        VertexShader = compile vs_3_0 Shadow_VS(face); \
        PixelShader = compile ps_3_0 Shadow_PS(face); }

technique ShadowTec <
    string MMDPass = "shadow";
    string Script = UE4LIKEIBL_TEC_SCRIPT_DEF(DrawShadow); >
{
    UE4LIKEIBL_DRAWSHADOW_PASS_DEF(0)
    UE4LIKEIBL_DRAWSHADOW_PASS_DEF(1)
    UE4LIKEIBL_DRAWSHADOW_PASS_DEF(2)
    UE4LIKEIBL_DRAWSHADOW_PASS_DEF(3)
    UE4LIKEIBL_DRAWSHADOW_PASS_DEF(4)
    UE4LIKEIBL_DRAWSHADOW_PASS_DEF(5)
}

#else
technique ShadowTec < string MMDPass = "shadow"; > {
    pass DrawShadow {
        VertexShader = compile vs_2_0 Shadow_VS();
        PixelShader  = compile ps_2_0 Shadow_PS();
    }
}
#endif

///////////////////////////////////////////////////////////////////////////////////////////////
